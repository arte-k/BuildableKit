# 🧱 BuildableKit

> A Swift macro library that generates **type-safe Builder patterns** from your models — automatically and with **compile-time enforcement of call order**.

No boilerplate, no duplicated “setters,” no unsafe dynamic chaining.
Just annotate your struct and get a fluent, ordered builder instantly.

---

## ✨ Features

✅ Compile-time enforced step order  
✅ Optional and required fields  
✅ Repeatable `add*` steps for arrays / dictionaries  
✅ Works with Swift 5.9+ / 6.0+ (macros)  
✅ Integrated easily via Swift Package Manager  

---

## 🧩 Installation

Add this package to your project via **Swift Package Manager**:

```swift
.package(url: "https://github.com/yourname/BuildableKit.git", from: "0.1.5")
```

Then add the dependencies to your target:

```swift
.target(
    name: "App",
    dependencies: [
        .product(name: "Buildable", package: "BuildableKit"),
        .product(name: "BuildableMacros", package: "BuildableKit")
    ]
)
```

---

## 🚀 Usage

Import both modules:

```swift
import Buildable
```

Annotate your model:

```swift
@Buildable
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String] = [:]
}
```

Now you can create a fully typed builder:

```swift
let request = Request.builder
    .setUrl(URL(string: "https://api.apple.com")!)
    .setMethod("POST")
    .setHeaders(["Content-Type", "application/json"])
    .build()
```

If you try to skip a required step or call them in the wrong order —  
💥 **compile error**, not runtime bug.

---

## 🧠 Under the Hood

When you mark a model with `@Buildable`, the macro generates a **chain of builder stages** that represent each step in the order you define.

Using the `Request` example above, the macro expands roughly into this:

```swift
@Buildable
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String]
}

// MARK: - Generated by @Buildable
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String]
    
    public enum Start {}
    public enum HasUrl {}
    public enum HasMethod {}
    public enum HasHeaders {}
}

public struct RequestBuilder<State> {
    public var url: URL?
    public var method: String?
    public var headers: [String:String]?

    
    public init(url: URL? = nil, method: String? = nil, headers: [String : String]) {
        self.url = url
        self.method = method
        self.headers = headers
    }
    
    public init() {}
    
    public func setURL(_ value: String) -> RequestBuilder<Person.HasUrl> where State == Request.Start  {
        RequestBuilder<Person.HasUrl>(url: value)
    }

    public func setMethod(_ value: String) -> RequestBuilder<Person.HasMethod> where State == Request.HasUrl {
        RequestBuilder<Request.HasAge>(url: self.url, method: value)
    }
    
    public func setHeaders(_ value: [String:String]) -> RequestBuilder<Person.HasHeaders> where State == Request.HasMethod {
        RequestBuilder<Request.HasHeaders>(url: self.url, method: self.method, headers: value)
    }
    
    public func build() -> Request where State == Request.HasHeaders {
        Request(url: self.url!, method: self.method!, headers: self.headers!)
    }
}
```

So when you write:

```swift
Request.builder
    .setUrl(...)
    .setMethod(...)
    .addHeader(...)
    .build()
```

you’re actually chaining **different types**, each one allowing *only* the next valid method.  
That’s why you can’t accidentally skip steps or reorder calls.

---

## 🧩 Another Example

```swift
@Buildable
public struct AnalyticsEvent {
    public var name: String
    public var userId: UUID
    public var properties: [String:String] = [:]
}
```

Usage:

```swift
let event = AnalyticsEvent.builder
    .setName("SubscriptionStarted")
    .setUserId(UUID())
    .prop("plan", "pro")
    .prop("country", "UA")
    .build()
```

---

## ⚙️ Requirements

- Xcode 15.4+ (Swift 5.10) or Xcode 16 (Swift 6.0)
- Works on macOS 13+ / iOS 15+
- Uses Swift Macros (compiler plugin)

---

## 🧾 License

MIT © 2025 Artem K.

---

### ❤️ Contributing

PRs and ideas welcome!  
Open an issue if you want to extend typestate builders, optional steps, or result-builder-style declarative syntax.
