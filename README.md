# ğŸ§± BuildableKit

> A Swift macro library that generates **type-safe Builder patterns** from your models â€” automatically and with **compile-time enforcement of call order**.

No boilerplate, no duplicated â€œsetters,â€ no unsafe dynamic chaining.
Just annotate your struct and get a fluent, ordered builder instantly.

---

## âœ¨ Features

âœ… Compile-time enforced step order  
âœ… Optional and required fields  
âœ… Repeatable `add*` steps for arrays / dictionaries  
âœ… Works with Swift 5.9+ / 6.0+ (macros)  
âœ… Integrated easily via Swift Package Manager  

---

## ğŸ§© Installation

Add this package to your project via **Swift Package Manager**:

```swift
.package(url: "https://github.com/yourname/BuildableKit.git", from: "0.1.0")
```

Then add the dependencies to your target:

```swift
.target(
    name: "App",
    dependencies: [
        .product(name: "Buildable", package: "BuildableKit"),
        .product(name: "BuildableMacros", package: "BuildableKit")
    ]
)
```

---

## ğŸš€ Usage

Import both modules:

```swift
import Buildable
import BuildableMacros
```

Annotate your model:

```swift
@Buildable(order: ["url", "method", "headers"])
public struct Request {
    @Required public var url: URL
    @Required public var method: String
    @Accumulating(adder: "addHeader") public var headers: [String:String] = [:]
}
```

Now you can create a fully typed builder:

```swift
let request = Request.Builder()
    .setUrl(URL(string: "https://api.apple.com")!)
    .setMethod("POST")
    .addHeader("Content-Type", "application/json")
    .addHeader("Accept", "application/json")
    .build()
```

If you try to skip a required step or call them in the wrong order â€”  
ğŸ’¥ **compile error**, not runtime bug.

---

## ğŸ§  Under the Hood

When you mark a model with `@Buildable`, the macro generates a **chain of builder stages** that represent each step in the order you define.

Using the `Request` example above, the macro expands roughly into this:

```swift
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String]
}

// MARK: - Generated by @Buildable
public struct RequestBuilderStage0 {
    public func setUrl(_ value: URL) -> RequestBuilderStage1 {
        .init(url: value)
    }
}

public struct RequestBuilderStage1 {
    let url: URL
    public func setMethod(_ value: String) -> RequestBuilderStage2 {
        .init(url: url, method: value)
    }
}

public struct RequestBuilderStage2 {
    let url: URL
    let method: String
    var headers: [String:String] = [:]

    public func addHeader(_ key: String, _ value: String) -> Self {
        var copy = self
        copy.headers[key] = value
        return copy
    }

    public func build() -> Request {
        Request(url: url, method: method, headers: headers)
    }
}

extension Request {
    public struct Builder {
        public init() {}
        public func start() -> RequestBuilderStage0 { .init() }
        public callAsFunction() -> RequestBuilderStage0 { start() }
    }
}
```

So when you write:

```swift
Request.Builder()
    .setUrl(...)
    .setMethod(...)
    .addHeader(...)
    .build()
```

youâ€™re actually chaining **different types**, each one allowing *only* the next valid method.  
Thatâ€™s why you canâ€™t accidentally skip steps or reorder calls.

---

## ğŸ§© Another Example

```swift
@Buildable(order: ["name", "userId", "properties"])
public struct AnalyticsEvent {
    @Required public var name: String
    @Required public var userId: UUID
    @Accumulating(adder: "prop") public var properties: [String:String] = [:]
}
```

Usage:

```swift
let event = AnalyticsEvent.Builder()
    .setName("SubscriptionStarted")
    .setUserId(UUID())
    .prop("plan", "pro")
    .prop("country", "UA")
    .build()
```

---

## ğŸ§± Why BuildableKit?

Because fluent builders are great â€” but hand-rolling them is painful.

| Before | After |
|--------|--------|
| dozens of boilerplate setters | 1 annotation |
| runtime misuse (forgot to set field) | compile-time check |
| untyped dictionary passing | fully typed steps |
| messy â€œinit hellâ€ | readable chain |

---

## ğŸ§° Advanced Topics

- You can omit `order:` â†’ fields are used in declaration order.  
- `@Accumulating` works with arrays, dictionaries, and sets.  
- Future versions will support:
  - Optional steps (`@Optional`)
  - Default values
  - Diagnostics for misuse
  - `consuming` functions for Swift 6 strict ownership

---

## âš™ï¸ Requirements

- Xcode 15.4+ (Swift 5.10) or Xcode 16 (Swift 6.0)
- Works on macOS 13+ / iOS 15+
- Uses Swift Macros (compiler plugin)

---

## ğŸ§¾ License

MIT Â© 2025 Artem K.

---

### â¤ï¸ Contributing

PRs and ideas welcome!  
Open an issue if you want to extend typestate builders, optional steps, or result-builder-style declarative syntax.
