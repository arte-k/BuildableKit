# ğŸ§± BuildableKit

> A Swift macro library that generates **type-safe Builder patterns** from your models â€” automatically and with **compile-time enforcement of call order**.

No boilerplate, no duplicated â€œsetters,â€ no unsafe dynamic chaining.
Just annotate your struct and get a fluent, ordered builder instantly.

---

## âœ¨ Features

âœ… Compile-time enforced step order  
âœ… Optional and required fields  
âœ… Repeatable `add*` steps for arrays / dictionaries  
âœ… Works with Swift 5.9+ / 6.0+ (macros)  
âœ… Integrated easily via Swift Package Manager  

---

## ğŸ§© Installation

Add this package to your project via **Swift Package Manager**:

```swift
.package(url: "https://github.com/yourname/BuildableKit.git", from: "0.1.5")
```

Then add the dependencies to your target:

```swift
.target(
    name: "App",
    dependencies: [
        .product(name: "Buildable", package: "BuildableKit"),
        .product(name: "BuildableMacros", package: "BuildableKit")
    ]
)
```

---

## ğŸš€ Usage

Import both modules:

```swift
import Buildable
```

Annotate your model:

```swift
@Buildable
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String] = [:]
}
```

Now you can create a fully typed builder:

```swift
let request = Request.builder
    .setUrl(URL(string: "https://api.apple.com")!)
    .setMethod("POST")
    .setHeaders(["Content-Type", "application/json"])
    .build()
```

If you try to skip a required step or call them in the wrong order â€”  
ğŸ’¥ **compile error**, not runtime bug.

---

## ğŸ§  Under the Hood

When you mark a model with `@Buildable`, the macro generates a **chain of builder stages** that represent each step in the order you define.

Using the `Request` example above, the macro expands roughly into this:

```swift
@Buildable
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String]
}

// MARK: - Generated by @Buildable
public struct Request {
    public var url: URL
    public var method: String
    public var headers: [String:String]
    
    public enum Start {}
    public enum HasUrl {}
    public enum HasMethod {}
    public enum HasHeaders {}
}

public struct RequestBuilder<State> {
    public var url: URL?
    public var method: String?
    public var headers: [String:String]?

    
    public init(url: URL? = nil, method: String? = nil, headers: [String : String]) {
        self.url = url
        self.method = method
        self.headers = headers
    }
    
    public init() {}
    
    public func setURL(_ value: String) -> RequestBuilder<Person.HasUrl> where State == Request.Start  {
        RequestBuilder<Person.HasUrl>(url: value)
    }

    public func setMethod(_ value: String) -> RequestBuilder<Person.HasMethod> where State == Request.HasUrl {
        RequestBuilder<Request.HasAge>(url: self.url, method: value)
    }
    
    public func setHeaders(_ value: [String:String]) -> RequestBuilder<Person.HasHeaders> where State == Request.HasMethod {
        RequestBuilder<Request.HasHeaders>(url: self.url, method: self.method, headers: value)
    }
    
    public func build() -> Request where State == Request.HasHeaders {
        Request(url: self.url!, method: self.method!, headers: self.headers!)
    }
}
```

So when you write:

```swift
Request.builder
    .setUrl(...)
    .setMethod(...)
    .addHeader(...)
    .build()
```

youâ€™re actually chaining **different types**, each one allowing *only* the next valid method.  
Thatâ€™s why you canâ€™t accidentally skip steps or reorder calls.

---

## ğŸ§© Another Example

```swift
@Buildable
public struct AnalyticsEvent {
    public var name: String
    public var userId: UUID
    public var properties: [String:String] = [:]
}
```

Usage:

```swift
let event = AnalyticsEvent.builder
    .setName("SubscriptionStarted")
    .setUserId(UUID())
    .prop("plan", "pro")
    .prop("country", "UA")
    .build()
```

---

## âš™ï¸ Requirements

- Xcode 15.4+ (Swift 5.10) or Xcode 16 (Swift 6.0)
- Works on macOS 13+ / iOS 15+
- Uses Swift Macros (compiler plugin)

---

## ğŸ§¾ License

MIT Â© 2025 Artem K.

---

### â¤ï¸ Contributing

PRs and ideas welcome!  
Open an issue if you want to extend typestate builders, optional steps, or result-builder-style declarative syntax.
